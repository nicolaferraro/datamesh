// Code generated by protoc-gen-go. DO NOT EDIT.
// source: protobuf/datamesh.proto

/*
Package protobuf is a generated protocol buffer package.

It is generated from these files:
	protobuf/datamesh.proto

It has these top-level messages:
	Transaction
	Operation
	ReadOperation
	UpsertOperation
	DeleteOperation
	GenerateEventOperation
	ApplicationFailure
	Event
	ReadRequest
	Path
	Data
	Status
	Context
	Readiness
	Empty
*/
package protobuf

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A transaction is a sequence of operation triggered by a event.
type Transaction struct {
	// The trigger
	Event *Event `protobuf:"bytes,1,opt,name=event" json:"event,omitempty"`
	// The projection context
	Context *Context `protobuf:"bytes,2,opt,name=context" json:"context,omitempty"`
	// The operations
	Operations []*Operation `protobuf:"bytes,3,rep,name=operations" json:"operations,omitempty"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (m *Transaction) String() string            { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Transaction) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Transaction) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Transaction) GetOperations() []*Operation {
	if m != nil {
		return m.Operations
	}
	return nil
}

type Operation struct {
	// Types that are valid to be assigned to Kind:
	//	*Operation_Read
	//	*Operation_Upsert
	//	*Operation_Delete
	//	*Operation_Generate
	//	*Operation_Failure
	Kind isOperation_Kind `protobuf_oneof:"kind"`
}

func (m *Operation) Reset()                    { *m = Operation{} }
func (m *Operation) String() string            { return proto.CompactTextString(m) }
func (*Operation) ProtoMessage()               {}
func (*Operation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isOperation_Kind interface {
	isOperation_Kind()
}

type Operation_Read struct {
	Read *ReadOperation `protobuf:"bytes,1,opt,name=read,oneof"`
}
type Operation_Upsert struct {
	Upsert *UpsertOperation `protobuf:"bytes,2,opt,name=upsert,oneof"`
}
type Operation_Delete struct {
	Delete *DeleteOperation `protobuf:"bytes,3,opt,name=delete,oneof"`
}
type Operation_Generate struct {
	Generate *GenerateEventOperation `protobuf:"bytes,4,opt,name=generate,oneof"`
}
type Operation_Failure struct {
	Failure *ApplicationFailure `protobuf:"bytes,5,opt,name=failure,oneof"`
}

func (*Operation_Read) isOperation_Kind()     {}
func (*Operation_Upsert) isOperation_Kind()   {}
func (*Operation_Delete) isOperation_Kind()   {}
func (*Operation_Generate) isOperation_Kind() {}
func (*Operation_Failure) isOperation_Kind()  {}

func (m *Operation) GetKind() isOperation_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *Operation) GetRead() *ReadOperation {
	if x, ok := m.GetKind().(*Operation_Read); ok {
		return x.Read
	}
	return nil
}

func (m *Operation) GetUpsert() *UpsertOperation {
	if x, ok := m.GetKind().(*Operation_Upsert); ok {
		return x.Upsert
	}
	return nil
}

func (m *Operation) GetDelete() *DeleteOperation {
	if x, ok := m.GetKind().(*Operation_Delete); ok {
		return x.Delete
	}
	return nil
}

func (m *Operation) GetGenerate() *GenerateEventOperation {
	if x, ok := m.GetKind().(*Operation_Generate); ok {
		return x.Generate
	}
	return nil
}

func (m *Operation) GetFailure() *ApplicationFailure {
	if x, ok := m.GetKind().(*Operation_Failure); ok {
		return x.Failure
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Operation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Operation_OneofMarshaler, _Operation_OneofUnmarshaler, _Operation_OneofSizer, []interface{}{
		(*Operation_Read)(nil),
		(*Operation_Upsert)(nil),
		(*Operation_Delete)(nil),
		(*Operation_Generate)(nil),
		(*Operation_Failure)(nil),
	}
}

func _Operation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Operation)
	// kind
	switch x := m.Kind.(type) {
	case *Operation_Read:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Read); err != nil {
			return err
		}
	case *Operation_Upsert:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Upsert); err != nil {
			return err
		}
	case *Operation_Delete:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Delete); err != nil {
			return err
		}
	case *Operation_Generate:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Generate); err != nil {
			return err
		}
	case *Operation_Failure:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Failure); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Operation.Kind has unexpected type %T", x)
	}
	return nil
}

func _Operation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Operation)
	switch tag {
	case 1: // kind.read
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReadOperation)
		err := b.DecodeMessage(msg)
		m.Kind = &Operation_Read{msg}
		return true, err
	case 2: // kind.upsert
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UpsertOperation)
		err := b.DecodeMessage(msg)
		m.Kind = &Operation_Upsert{msg}
		return true, err
	case 3: // kind.delete
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeleteOperation)
		err := b.DecodeMessage(msg)
		m.Kind = &Operation_Delete{msg}
		return true, err
	case 4: // kind.generate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateEventOperation)
		err := b.DecodeMessage(msg)
		m.Kind = &Operation_Generate{msg}
		return true, err
	case 5: // kind.failure
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ApplicationFailure)
		err := b.DecodeMessage(msg)
		m.Kind = &Operation_Failure{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Operation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Operation)
	// kind
	switch x := m.Kind.(type) {
	case *Operation_Read:
		s := proto.Size(x.Read)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Operation_Upsert:
		s := proto.Size(x.Upsert)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Operation_Delete:
		s := proto.Size(x.Delete)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Operation_Generate:
		s := proto.Size(x.Generate)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Operation_Failure:
		s := proto.Size(x.Failure)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ReadOperation struct {
	Path *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *ReadOperation) Reset()                    { *m = ReadOperation{} }
func (m *ReadOperation) String() string            { return proto.CompactTextString(m) }
func (*ReadOperation) ProtoMessage()               {}
func (*ReadOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ReadOperation) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

type UpsertOperation struct {
	Data *Data `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *UpsertOperation) Reset()                    { *m = UpsertOperation{} }
func (m *UpsertOperation) String() string            { return proto.CompactTextString(m) }
func (*UpsertOperation) ProtoMessage()               {}
func (*UpsertOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UpsertOperation) GetData() *Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type DeleteOperation struct {
	Path *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *DeleteOperation) Reset()                    { *m = DeleteOperation{} }
func (m *DeleteOperation) String() string            { return proto.CompactTextString(m) }
func (*DeleteOperation) ProtoMessage()               {}
func (*DeleteOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DeleteOperation) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

type GenerateEventOperation struct {
	Event *Event `protobuf:"bytes,1,opt,name=event" json:"event,omitempty"`
}

func (m *GenerateEventOperation) Reset()                    { *m = GenerateEventOperation{} }
func (m *GenerateEventOperation) String() string            { return proto.CompactTextString(m) }
func (*GenerateEventOperation) ProtoMessage()               {}
func (*GenerateEventOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GenerateEventOperation) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

// To be used automatically in case of runtime errors (usually bugs)
type ApplicationFailure struct {
	Reason string `protobuf:"bytes,1,opt,name=reason" json:"reason,omitempty"`
}

func (m *ApplicationFailure) Reset()                    { *m = ApplicationFailure{} }
func (m *ApplicationFailure) String() string            { return proto.CompactTextString(m) }
func (*ApplicationFailure) ProtoMessage()               {}
func (*ApplicationFailure) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ApplicationFailure) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// A Event object may model a command (action to executed) or a proper event (action happened in the past)
type Event struct {
	Group   string `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Payload []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	// Client identifier is used to match the logged Event with a Transaction in case of fast-path processing
	ClientIdentifier string `protobuf:"bytes,4,opt,name=client_identifier,json=clientIdentifier" json:"client_identifier,omitempty"`
	// Client version should be made visible to client API
	ClientVersion string `protobuf:"bytes,5,opt,name=client_version,json=clientVersion" json:"client_version,omitempty"`
	// Version is meaningful only when event is stored (0 before)
	Version uint64 `protobuf:"varint,6,opt,name=version" json:"version,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Event) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Event) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Event) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Event) GetClientIdentifier() string {
	if m != nil {
		return m.ClientIdentifier
	}
	return ""
}

func (m *Event) GetClientVersion() string {
	if m != nil {
		return m.ClientVersion
	}
	return ""
}

func (m *Event) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// A read request
type ReadRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Path    *Path    `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ReadRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ReadRequest) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

// A path in the projection store
type Path struct {
	Location string `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Version  uint64 `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Path) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Path) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// The object contained in a specific Path
type Data struct {
	Path *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// JSON encoded content
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *Data) Reset()                    { *m = Data{} }
func (m *Data) String() string            { return proto.CompactTextString(m) }
func (*Data) ProtoMessage()               {}
func (*Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Data) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Data) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

// The status of a connected client
type Status struct {
	// Types that are valid to be assigned to Status:
	//	*Status_Connect
	//	*Status_Disconnect
	//	*Status_Ping
	Status isStatus_Status `protobuf_oneof:"status"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isStatus_Status interface {
	isStatus_Status()
}

type Status_Connect struct {
	Connect *Context `protobuf:"bytes,1,opt,name=connect,oneof"`
}
type Status_Disconnect struct {
	Disconnect *Empty `protobuf:"bytes,2,opt,name=disconnect,oneof"`
}
type Status_Ping struct {
	Ping *Empty `protobuf:"bytes,3,opt,name=ping,oneof"`
}

func (*Status_Connect) isStatus_Status()    {}
func (*Status_Disconnect) isStatus_Status() {}
func (*Status_Ping) isStatus_Status()       {}

func (m *Status) GetStatus() isStatus_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Status) GetConnect() *Context {
	if x, ok := m.GetStatus().(*Status_Connect); ok {
		return x.Connect
	}
	return nil
}

func (m *Status) GetDisconnect() *Empty {
	if x, ok := m.GetStatus().(*Status_Disconnect); ok {
		return x.Disconnect
	}
	return nil
}

func (m *Status) GetPing() *Empty {
	if x, ok := m.GetStatus().(*Status_Ping); ok {
		return x.Ping
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Status) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Status_OneofMarshaler, _Status_OneofUnmarshaler, _Status_OneofSizer, []interface{}{
		(*Status_Connect)(nil),
		(*Status_Disconnect)(nil),
		(*Status_Ping)(nil),
	}
}

func _Status_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Status)
	// status
	switch x := m.Status.(type) {
	case *Status_Connect:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Connect); err != nil {
			return err
		}
	case *Status_Disconnect:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Disconnect); err != nil {
			return err
		}
	case *Status_Ping:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ping); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Status.Status has unexpected type %T", x)
	}
	return nil
}

func _Status_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Status)
	switch tag {
	case 1: // status.connect
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Context)
		err := b.DecodeMessage(msg)
		m.Status = &Status_Connect{msg}
		return true, err
	case 2: // status.disconnect
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.Status = &Status_Disconnect{msg}
		return true, err
	case 3: // status.ping
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.Status = &Status_Ping{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Status_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Status)
	// status
	switch x := m.Status.(type) {
	case *Status_Connect:
		s := proto.Size(x.Connect)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Status_Disconnect:
		s := proto.Size(x.Disconnect)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Status_Ping:
		s := proto.Size(x.Ping)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A context representing the projection to which a client is connected
type Context struct {
	Name     string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Revision uint64 `protobuf:"varint,2,opt,name=revision" json:"revision,omitempty"`
}

func (m *Context) Reset()                    { *m = Context{} }
func (m *Context) String() string            { return proto.CompactTextString(m) }
func (*Context) ProtoMessage()               {}
func (*Context) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Context) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Context) GetRevision() uint64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

// Readiness data about a context
type Readiness struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Ready   bool     `protobuf:"varint,2,opt,name=ready" json:"ready,omitempty"`
}

func (m *Readiness) Reset()                    { *m = Readiness{} }
func (m *Readiness) String() string            { return proto.CompactTextString(m) }
func (*Readiness) ProtoMessage()               {}
func (*Readiness) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Readiness) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Readiness) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

// A placeholder for empty message
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func init() {
	proto.RegisterType((*Transaction)(nil), "protobuf.Transaction")
	proto.RegisterType((*Operation)(nil), "protobuf.Operation")
	proto.RegisterType((*ReadOperation)(nil), "protobuf.ReadOperation")
	proto.RegisterType((*UpsertOperation)(nil), "protobuf.UpsertOperation")
	proto.RegisterType((*DeleteOperation)(nil), "protobuf.DeleteOperation")
	proto.RegisterType((*GenerateEventOperation)(nil), "protobuf.GenerateEventOperation")
	proto.RegisterType((*ApplicationFailure)(nil), "protobuf.ApplicationFailure")
	proto.RegisterType((*Event)(nil), "protobuf.Event")
	proto.RegisterType((*ReadRequest)(nil), "protobuf.ReadRequest")
	proto.RegisterType((*Path)(nil), "protobuf.Path")
	proto.RegisterType((*Data)(nil), "protobuf.Data")
	proto.RegisterType((*Status)(nil), "protobuf.Status")
	proto.RegisterType((*Context)(nil), "protobuf.Context")
	proto.RegisterType((*Readiness)(nil), "protobuf.Readiness")
	proto.RegisterType((*Empty)(nil), "protobuf.Empty")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DataMesh service

type DataMeshClient interface {
	// Used to push a event that will be stored on the event log.
	Push(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error)
	// Allows to pass a transaction related to a event before it's explicitly requested.
	Process(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*Empty, error)
	// The server sends events that need to be processed. The client will reply with the corresponding transactions asynchronously.
	Connect(ctx context.Context, opts ...grpc.CallOption) (DataMesh_ConnectClient, error)
	// Used by the client to query the projections.
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*Data, error)
	// Used by the client to check if a projection is ready.
	Health(ctx context.Context, in *Context, opts ...grpc.CallOption) (*Readiness, error)
}

type dataMeshClient struct {
	cc *grpc.ClientConn
}

func NewDataMeshClient(cc *grpc.ClientConn) DataMeshClient {
	return &dataMeshClient{cc}
}

func (c *dataMeshClient) Push(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/protobuf.DataMesh/Push", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataMeshClient) Process(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/protobuf.DataMesh/Process", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataMeshClient) Connect(ctx context.Context, opts ...grpc.CallOption) (DataMesh_ConnectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataMesh_serviceDesc.Streams[0], c.cc, "/protobuf.DataMesh/Connect", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataMeshConnectClient{stream}
	return x, nil
}

type DataMesh_ConnectClient interface {
	Send(*Status) error
	Recv() (*Event, error)
	grpc.ClientStream
}

type dataMeshConnectClient struct {
	grpc.ClientStream
}

func (x *dataMeshConnectClient) Send(m *Status) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataMeshConnectClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataMeshClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*Data, error) {
	out := new(Data)
	err := grpc.Invoke(ctx, "/protobuf.DataMesh/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataMeshClient) Health(ctx context.Context, in *Context, opts ...grpc.CallOption) (*Readiness, error) {
	out := new(Readiness)
	err := grpc.Invoke(ctx, "/protobuf.DataMesh/Health", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DataMesh service

type DataMeshServer interface {
	// Used to push a event that will be stored on the event log.
	Push(context.Context, *Event) (*Empty, error)
	// Allows to pass a transaction related to a event before it's explicitly requested.
	Process(context.Context, *Transaction) (*Empty, error)
	// The server sends events that need to be processed. The client will reply with the corresponding transactions asynchronously.
	Connect(DataMesh_ConnectServer) error
	// Used by the client to query the projections.
	Read(context.Context, *ReadRequest) (*Data, error)
	// Used by the client to check if a projection is ready.
	Health(context.Context, *Context) (*Readiness, error)
}

func RegisterDataMeshServer(s *grpc.Server, srv DataMeshServer) {
	s.RegisterService(&_DataMesh_serviceDesc, srv)
}

func _DataMesh_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataMeshServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.DataMesh/Push",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataMeshServer).Push(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataMesh_Process_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataMeshServer).Process(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.DataMesh/Process",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataMeshServer).Process(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataMesh_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataMeshServer).Connect(&dataMeshConnectServer{stream})
}

type DataMesh_ConnectServer interface {
	Send(*Event) error
	Recv() (*Status, error)
	grpc.ServerStream
}

type dataMeshConnectServer struct {
	grpc.ServerStream
}

func (x *dataMeshConnectServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataMeshConnectServer) Recv() (*Status, error) {
	m := new(Status)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataMesh_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataMeshServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.DataMesh/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataMeshServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataMesh_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Context)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataMeshServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.DataMesh/Health",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataMeshServer).Health(ctx, req.(*Context))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataMesh_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protobuf.DataMesh",
	HandlerType: (*DataMeshServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _DataMesh_Push_Handler,
		},
		{
			MethodName: "Process",
			Handler:    _DataMesh_Process_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _DataMesh_Read_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _DataMesh_Health_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _DataMesh_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "protobuf/datamesh.proto",
}

func init() { proto.RegisterFile("protobuf/datamesh.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 731 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x5d, 0x6f, 0xd3, 0x4a,
	0x10, 0x8d, 0x53, 0xc7, 0x49, 0x26, 0xfd, 0xdc, 0xf6, 0xb6, 0xb9, 0xd1, 0x7d, 0x88, 0x56, 0xb7,
	0x52, 0x44, 0x69, 0x0a, 0x89, 0x90, 0x40, 0x42, 0x20, 0x4a, 0x81, 0xf0, 0x00, 0x54, 0xcb, 0xc7,
	0x23, 0x68, 0x1b, 0x6f, 0x1a, 0x0b, 0x67, 0x6d, 0xd6, 0xeb, 0x8a, 0xbe, 0xf3, 0x1b, 0x78, 0xe1,
	0x9d, 0xff, 0xc0, 0xbf, 0x43, 0x3b, 0xb6, 0x63, 0xc7, 0x29, 0x50, 0xde, 0x32, 0x73, 0xce, 0xd9,
	0x19, 0x9f, 0x99, 0xdd, 0xc0, 0x5e, 0xa8, 0x02, 0x1d, 0x9c, 0xc5, 0x93, 0x23, 0x97, 0x6b, 0x3e,
	0x13, 0xd1, 0xb4, 0x8f, 0x19, 0xd2, 0xc8, 0x00, 0xfa, 0xd5, 0x82, 0xd6, 0x1b, 0xc5, 0x65, 0xc4,
	0xc7, 0xda, 0x0b, 0x24, 0xd9, 0x87, 0x9a, 0xb8, 0x10, 0x52, 0xb7, 0xad, 0xae, 0xd5, 0x6b, 0x0d,
	0x36, 0xfa, 0x19, 0xb3, 0xff, 0xc4, 0xa4, 0x59, 0x82, 0x92, 0x03, 0xa8, 0x8f, 0x03, 0xa9, 0xc5,
	0x67, 0xdd, 0xae, 0x22, 0x71, 0x2b, 0x27, 0x3e, 0x4e, 0x00, 0x96, 0x31, 0xc8, 0x10, 0x20, 0x08,
	0x85, 0xe2, 0xa6, 0x40, 0xd4, 0x5e, 0xe9, 0xae, 0xf4, 0x5a, 0x83, 0xed, 0x9c, 0xff, 0x2a, 0xc3,
	0x58, 0x81, 0x46, 0xbf, 0x57, 0xa1, 0x39, 0x47, 0xc8, 0x21, 0xd8, 0x4a, 0x70, 0x37, 0xed, 0x6a,
	0x2f, 0x17, 0x33, 0xc1, 0xdd, 0x39, 0x6d, 0x54, 0x61, 0x48, 0x23, 0x43, 0x70, 0xe2, 0x30, 0x12,
	0x2a, 0xeb, 0xee, 0xdf, 0x5c, 0xf0, 0x16, 0xf3, 0x45, 0x49, 0x4a, 0x35, 0x22, 0x57, 0xf8, 0x42,
	0x8b, 0xf6, 0x4a, 0x59, 0x74, 0x82, 0xf9, 0x05, 0x51, 0x42, 0x25, 0x0f, 0xa0, 0x71, 0x2e, 0xa4,
	0xc9, 0x8b, 0xb6, 0x8d, 0xb2, 0x6e, 0x2e, 0x7b, 0x96, 0x22, 0x68, 0x5d, 0x51, 0x3d, 0xd7, 0x90,
	0xbb, 0x50, 0x9f, 0x70, 0xcf, 0x8f, 0x95, 0x68, 0xd7, 0x50, 0xfe, 0x5f, 0x2e, 0x7f, 0x14, 0x86,
	0xbe, 0x37, 0x46, 0xcd, 0xd3, 0x84, 0x33, 0xaa, 0xb0, 0x8c, 0x7e, 0xec, 0x80, 0xfd, 0xd1, 0x93,
	0x2e, 0x1d, 0xc2, 0xda, 0x82, 0x09, 0x84, 0x82, 0x1d, 0x72, 0x3d, 0x4d, 0xbd, 0x5a, 0xcf, 0xcf,
	0x3b, 0xe5, 0x7a, 0xca, 0x10, 0xa3, 0x77, 0x60, 0xa3, 0x64, 0x84, 0x91, 0x99, 0x2d, 0x59, 0x96,
	0x9d, 0x70, 0xcd, 0x19, 0x62, 0x46, 0x56, 0xb2, 0xe2, 0x5a, 0xd5, 0x1e, 0xc2, 0xee, 0xd5, 0x56,
	0x5c, 0x73, 0xdd, 0xe8, 0x4d, 0x20, 0xcb, 0x66, 0x90, 0x5d, 0x70, 0x94, 0xe0, 0x51, 0x20, 0x51,
	0xdd, 0x64, 0x69, 0x44, 0x7f, 0x58, 0x50, 0x43, 0x39, 0xd9, 0x81, 0xda, 0xb9, 0x0a, 0xe2, 0x30,
	0x25, 0x24, 0x01, 0x21, 0x60, 0x4b, 0x3e, 0x13, 0xb8, 0x1b, 0x4d, 0x86, 0xbf, 0x49, 0x1b, 0xea,
	0x21, 0xbf, 0xf4, 0x03, 0xee, 0xe2, 0xf4, 0x57, 0x59, 0x16, 0x92, 0x03, 0xd8, 0x1a, 0xfb, 0x9e,
	0x90, 0xfa, 0x83, 0xe7, 0x0a, 0xa9, 0xbd, 0x89, 0x27, 0x14, 0x8e, 0xba, 0xc9, 0x36, 0x13, 0xe0,
	0xf9, 0x3c, 0x4f, 0xf6, 0x61, 0x3d, 0x25, 0x5f, 0x08, 0x15, 0x79, 0x81, 0xc4, 0xa9, 0x36, 0xd9,
	0x5a, 0x92, 0x7d, 0x97, 0x24, 0x4d, 0xb5, 0x0c, 0x77, 0xba, 0x56, 0xcf, 0x66, 0x59, 0x48, 0xdf,
	0x43, 0xcb, 0x4c, 0x93, 0x89, 0x4f, 0xb1, 0x88, 0x16, 0xee, 0x99, 0xf5, 0xc7, 0x7b, 0x96, 0x8d,
	0xa2, 0xfa, 0x9b, 0x51, 0xdc, 0x07, 0xdb, 0x44, 0xa4, 0x03, 0x0d, 0x3f, 0x48, 0xec, 0x4c, 0xcd,
	0x99, 0xc7, 0xc5, 0xee, 0xaa, 0x8b, 0xdd, 0x9d, 0x80, 0x6d, 0xb6, 0xe1, 0x3a, 0x43, 0x37, 0xa7,
	0x60, 0x63, 0x32, 0xb9, 0x84, 0xab, 0x2c, 0x0b, 0xe9, 0x37, 0x0b, 0x9c, 0xd7, 0x9a, 0xeb, 0x38,
	0x22, 0x87, 0x48, 0x92, 0x62, 0xfc, 0xeb, 0xef, 0x33, 0x3b, 0x9f, 0x72, 0xc8, 0x6d, 0x00, 0xd7,
	0x8b, 0x32, 0x45, 0x75, 0x69, 0x67, 0x66, 0xa1, 0xbe, 0x1c, 0x55, 0x58, 0x81, 0x44, 0xf6, 0xc1,
	0x0e, 0x3d, 0x79, 0x9e, 0xde, 0xe9, 0x2b, 0xc8, 0x08, 0x1f, 0x37, 0xc0, 0x89, 0xb0, 0x25, 0x7a,
	0x0f, 0xea, 0x69, 0xe5, 0xf9, 0xa2, 0x58, 0x85, 0x45, 0xe9, 0x40, 0x43, 0x89, 0x0b, 0xaf, 0xe0,
	0xce, 0x3c, 0xa6, 0x2f, 0xa1, 0x69, 0x86, 0xe7, 0x49, 0x11, 0x45, 0x7f, 0x37, 0xba, 0x1d, 0xa8,
	0x99, 0x87, 0xeb, 0x12, 0x8f, 0x6c, 0xb0, 0x24, 0xa0, 0x75, 0xa8, 0x61, 0x97, 0x83, 0x2f, 0x55,
	0x68, 0x18, 0xe3, 0x5f, 0x88, 0x68, 0x4a, 0x6e, 0x80, 0x7d, 0x1a, 0x47, 0x53, 0x52, 0xbe, 0x2c,
	0x9d, 0xf2, 0xc7, 0xd1, 0x0a, 0x19, 0x42, 0xfd, 0x54, 0x05, 0x63, 0xd3, 0xcf, 0x3f, 0x39, 0x5a,
	0x78, 0xf0, 0xaf, 0x12, 0x0d, 0xd0, 0x01, 0x74, 0x6f, 0x33, 0x47, 0x93, 0x89, 0x75, 0xca, 0x55,
	0x69, 0xa5, 0x67, 0xdd, 0xb2, 0xc8, 0x11, 0xd8, 0xe6, 0xd3, 0x8b, 0x55, 0x0a, 0x7b, 0xdc, 0x29,
	0x3d, 0x27, 0x58, 0xc4, 0x19, 0x09, 0xee, 0xeb, 0x29, 0x59, 0xf6, 0xa5, 0xb3, 0xbd, 0x78, 0x0a,
	0x1a, 0x4a, 0x2b, 0xc7, 0xff, 0x03, 0x9d, 0x89, 0xbe, 0xf4, 0xc6, 0x81, 0xcf, 0x27, 0x42, 0x29,
	0xae, 0x82, 0xfe, 0xe2, 0x3f, 0xdb, 0x59, 0x3c, 0x39, 0x73, 0xf0, 0xd7, 0xf0, 0x67, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xe9, 0xaa, 0x39, 0xd7, 0xfe, 0x06, 0x00, 0x00,
}
